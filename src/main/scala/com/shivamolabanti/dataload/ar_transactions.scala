package com.shivamolabanti.dataload

import com.shivamolabanti.common.ReadConfig
import org.apache.spark.sql.{SaveMode, SparkSession}

object ar_transactions {
  def main(args: Array[String]) {
    // Default Values
    var SQLdbtable = "KPI_FACT_AR_TRANSACTIONS"


    //Create Spark session and enable HIVE Support
    val sparksession = SparkSession.builder().appName(s"$SQLdbtable").config("spark.rdd.compress","true").config("spark.sql.caseSensitive","false").config("spark.shuffle.service.enabled","true").enableHiveSupport().getOrCreate()

    // Read application.conf file
    val hdfsPath = "/deploy/conf/application.conf"
    val config = ReadConfig.read(sparksession.sparkContext, hdfsPath)

    //Get the Application properties from application.conf file
    val hiveDB = config.getString("hive.hive-db")
    val TargetTable = config.getString(s"datamodel_info.$SQLdbtable.hive-table")
    val datamodelpath = config.getString(s"app.datamodel-path")
    val datamodelfile = config.getString(s"datamodel_info.$SQLdbtable.datamodel-filename").toUpperCase


    // construct the file path from the config file
    val datamodelscript = scala.io.Source.fromFile(datamodelpath+datamodelfile).mkString

    import sparksession.sql


    // Set the Target Database to be used to load the data
    sql(s"USE $hiveDB")

    // Few HIVE performance settings
    sparksession.conf.set("spark.sql.orc.filterPushdown", "true")
    sparksession.conf.set("spark.sql.orc.filterPushdown", "true")
    sql("set spark.sql.caseSensitive=false")

    // Create Spark Dataframe with datamodel script
    val DF1 = sql("SELECT 'INV' TRX_SOURCE,\n  T.CUSTOMER_TRX_ID RECORD_ID,\n  D.CUST_TRX_LINE_GL_DIST_ID DISTRIBUTION_ID,\n  T.CUSTOMER_TRX_ID ,\n  0 CASH_RECEIPT_ID,\n  0 ADJUSTMENT_ID,\n  CASE\n    WHEN AP.CLASS = 'CM'\n    THEN T.CUSTOMER_TRX_ID\n    ELSE 0\n  END CREDIT_MEMO_ID,\n  T.BILL_TO_CUSTOMER_ID,\n  T.BILL_TO_SITE_USE_ID,\n  T.BILL_TO_CONTACT_ID,\n  T.SHIP_TO_CUSTOMER_ID,\n  T.SHIP_TO_SITE_USE_ID,\n  T.SHIP_TO_CONTACT_ID ,\n  T.PRIMARY_SALESREP_ID,\n  HCA.PARTY_ID,\n  NVL(SHIP_HCA.PARTY_ID,0) SHIP_PARTY_ID,\n  AP.CLASS TRX_TYPE,\n  AP.STATUS TRX_STATUS,\n  T.ORG_ID,\n  T.SET_OF_BOOKS_ID LEDGER_ID,\n  T.TRX_NUMBER TRX_NUMBER,\n  T.TRX_DATE TRX_DATE,\n  T.INVOICE_CURRENCY_CODE TRX_CURRENCY,\n  LD1.CURRENCY_CODE LEDGER_CURRENCY,\n  D.CODE_COMBINATION_ID,\n  D.AMOUNT TRX_CURRENCY_AMOUNT,\n  D.ACCTD_AMOUNT LEDGER_CURRENCY_AMOUNT,\n  0 ACCTD_AMOUNT_APPLIED_FROM,\n  0 ACCTD_AMOUNT_APPLIED_TO,\n  D.GL_DATE,\n  T.CREATION_DATE TRX_CREATION_DATE,\n  T.LAST_UPDATE_DATE TRX_LAST_UPDATE_DATE\nFROM \nRA_CUSTOMER_TRX_ALL T INNER JOIN RA_CUST_TRX_LINE_GL_DIST_ALL D ON (T.CUSTOMER_TRX_ID = D.CUSTOMER_TRX_ID)\nLEFT OUTER JOIN AR_PAYMENT_SCHEDULES_ALL AP ON (T.CUSTOMER_TRX_ID= AP.CUSTOMER_TRX_ID)\nINNER JOIN GL_LEDGERS LD1 ON (T.SET_OF_BOOKS_ID     = LD1.LEDGER_ID)\nINNER JOIN HZ_CUST_ACCOUNTS HCA ON (T.BILL_TO_CUSTOMER_ID = HCA.CUST_ACCOUNT_ID)\nLEFT OUTER JOIN HZ_CUST_ACCOUNTS SHIP_HCA ON (T.SHIP_TO_CUSTOMER_ID = SHIP_HCA.CUST_ACCOUNT_ID)\nWHERE D.ACCOUNT_CLASS    = 'REC'\nAND D.LATEST_REC_FLAG  = 'Y'")

    val DF2 = sql("SELECT 'CASH' TRX_SOURCE,\n  CR.CASH_RECEIPT_ID RECORD_ID,\n  0 DISTRIBUTION_ID,\n  0 CUSTOMER_TRX_ID,\n  CR.CASH_RECEIPT_ID ,\n  0 ADJUSTMENT_ID,\n  0 CREDIT_MEMO_ID,\n  CR.PAY_FROM_CUSTOMER BILL_TO_CUSTOMER_ID,\n  CR.CUSTOMER_SITE_USE_ID BILL_TO_SITE_USE_ID,\n  0 BILL_TO_CONTACT_ID,\n  0 SHIP_TO_CUSTOMER_ID,\n  0 SHIP_TO_SITE_USE_ID,\n  0 SHIP_TO_CONTACT_ID ,\n  0 PRIMARY_SALESREP_ID,\n  HCA2.PARTY_ID,\n  0 SHIP_PARTY_ID,\n  CR.TYPE TRX_TYPE,\n  CR.STATUS TRX_STATUS,\n  CR.ORG_ID,\n  CR.SET_OF_BOOKS_ID LEDGER_ID,\n  CR.RECEIPT_NUMBER TRX_NUMBER,\n  CR.RECEIPT_DATE TRX_DATE,\n  CR.CURRENCY_CODE TRX_CURRENCY,\n  LD2.CURRENCY_CODE LEDGER_CURRENCY,\n  CH.ACCOUNT_CODE_COMBINATION_ID CODE_COMBINATION_ID,\n  CR.AMOUNT TRX_CURRENCY_AMOUNT,\n  ROUND(CR.AMOUNT*NVL(CR.EXCHANGE_RATE,1),8) LEDGER_CURRENCY_AMOUNT,\n  0 ACCTD_AMOUNT_APPLIED_FROM,\n  0 ACCTD_AMOUNT_APPLIED_TO,\n  CH.GL_DATE,\n  CR.CREATION_DATE TRX_CREATION_DATE,\n  CR.LAST_UPDATE_DATE TRX_LAST_UPDATE_DATE\nFROM\nAR_CASH_RECEIPTS_ALL CR INNER JOIN AR_CASH_RECEIPT_HISTORY_ALL CH ON (CR.CASH_RECEIPT_ID      = CH.CASH_RECEIPT_ID)\nINNER JOIN GL_LEDGERS LD2 ON (CR.SET_OF_BOOKS_ID      = LD2.LEDGER_ID)\nLEFT OUTER JOIN HZ_CUST_ACCOUNTS HCA2 ON (CR.PAY_FROM_CUSTOMER    = HCA2.CUST_ACCOUNT_ID)\nWHERE CH.CURRENT_RECORD_FLAG  = 'Y'")

    val DF3 = sql("SELECT 'CASH_APP' TRX_SOURCE,\n  R.RECEIVABLE_APPLICATION_ID RECORD_ID,\n  0 DISTRIBUTION_ID,\n  R.APPLIED_CUSTOMER_TRX_ID CUSTOMER_TRX_ID,\n  R.CASH_RECEIPT_ID,\n  0 ADJUSTMENT_ID,\n  0 CREDIT_MEMO_ID,\n  T.BILL_TO_CUSTOMER_ID,\n  T.BILL_TO_SITE_USE_ID,\n  T.BILL_TO_CONTACT_ID,\n  T.SHIP_TO_CUSTOMER_ID,\n  T.SHIP_TO_SITE_USE_ID,\n  T.SHIP_TO_CONTACT_ID ,\n  T.PRIMARY_SALESREP_ID,\n  HCA3.PARTY_ID,\n  NVL(SHIP_HCA.PARTY_ID,0) SHIP_PARTY_ID,\n  R.APPLICATION_TYPE TRX_TYPE,\n  R.STATUS TRX_STATUS,\n  R.ORG_ID,\n  R.SET_OF_BOOKS_ID LEDGER_ID,\n  NULL TRX_NUMBER,\n  R.APPLY_DATE TRX_DATE,\n  CR.CURRENCY_CODE TRX_CURRENCY,\n  LD3.CURRENCY_CODE LEDGER_CURRENCY,\n  R.CODE_COMBINATION_ID,\n  R.AMOUNT_APPLIED TRX_CURRENCY_AMOUNT,\n  ROUND(R.AMOUNT_APPLIED*NVL(CR.EXCHANGE_RATE,1), 8) LEDGER_CURRENCY_AMOUNT,\n  R.ACCTD_AMOUNT_APPLIED_FROM,\n  R.ACCTD_AMOUNT_APPLIED_TO,\n  R.GL_DATE,\n  R.CREATION_DATE TRX_CREATION_DATE,\n  R.LAST_UPDATE_DATE TRX_LAST_UPDATE_DATE\nFROM \nAR_RECEIVABLE_APPLICATIONS_ALL R LEFT OUTER JOIN RA_CUSTOMER_TRX_ALL T ON (R.APPLIED_CUSTOMER_TRX_ID = T.CUSTOMER_TRX_ID)\nINNER JOIN GL_LEDGERS LD3 ON (R.SET_OF_BOOKS_ID         = LD3.LEDGER_ID)\nINNER JOIN AR_CASH_RECEIPTS_ALL CR ON (R.CASH_RECEIPT_ID         = CR.CASH_RECEIPT_ID)\nLEFT OUTER JOIN HZ_CUST_ACCOUNTS HCA3 ON (T.BILL_TO_CUSTOMER_ID     = HCA3.CUST_ACCOUNT_ID)\nLEFT OUTER JOIN HZ_CUST_ACCOUNTS SHIP_HCA ON (T.SHIP_TO_CUSTOMER_ID = SHIP_HCA.CUST_ACCOUNT_ID)\nWHERE R.APPLICATION_TYPE = 'CASH'")

    val DF4 = sql("SELECT 'CM_APP' TRX_SOURCE,\n  R.RECEIVABLE_APPLICATION_ID RECORD_ID,\n  0 DISTRIBUTION_ID,\n  R.APPLIED_CUSTOMER_TRX_ID CUSTOMER_TRX_ID,\n  0 CASH_RECEIPT_ID,\n  0 ADJUSTMENT_ID,\n  R.CUSTOMER_TRX_ID CREDIT_MEMO_ID,\n  T.BILL_TO_CUSTOMER_ID,\n  T.BILL_TO_SITE_USE_ID,\n  T.BILL_TO_CONTACT_ID,\n  T.SHIP_TO_CUSTOMER_ID,\n  T.SHIP_TO_SITE_USE_ID,\n  T.SHIP_TO_CONTACT_ID ,\n  T.PRIMARY_SALESREP_ID,\n  HCA4.PARTY_ID,\n  NVL(SHIP_HCA.PARTY_ID,0) SHIP_PARTY_ID,\n  R.APPLICATION_TYPE TRX_TYPE,\n  R.STATUS TRX_STATUS,\n  R.ORG_ID,\n  R.SET_OF_BOOKS_ID LEDGER_ID,\n  NULL TRX_NUMBER,\n  R.APPLY_DATE TRX_DATE,\n  T.INVOICE_CURRENCY_CODE TRX_CURRENCY,\n  LD4.CURRENCY_CODE LEDGER_CURRENCY,\n  R.CODE_COMBINATION_ID,\n  R.AMOUNT_APPLIED TRX_CURRENCY_AMOUNT,\n  ROUND(R.AMOUNT_APPLIED*NVL(T.EXCHANGE_RATE,1), 8) LEDGER_CURRENCY_AMOUNT,\n  R.ACCTD_AMOUNT_APPLIED_FROM,\n  R.ACCTD_AMOUNT_APPLIED_TO,\n  R.GL_DATE,\n  R.CREATION_DATE TRX_CREATION_DATE,\n  R.LAST_UPDATE_DATE TRX_LAST_UPDATE_DATE\nFROM\nAR_RECEIVABLE_APPLICATIONS_ALL R LEFT OUTER JOIN RA_CUSTOMER_TRX_ALL T ON (R.APPLIED_CUSTOMER_TRX_ID = T.CUSTOMER_TRX_ID)\nINNER JOIN GL_LEDGERS LD4 ON (R.SET_OF_BOOKS_ID = LD4.LEDGER_ID)\nLEFT OUTER JOIN HZ_CUST_ACCOUNTS HCA4 ON (T.BILL_TO_CUSTOMER_ID = HCA4.CUST_ACCOUNT_ID)\nLEFT OUTER JOIN HZ_CUST_ACCOUNTS SHIP_HCA ON (T.SHIP_TO_CUSTOMER_ID = SHIP_HCA.CUST_ACCOUNT_ID)\nWHERE R.APPLICATION_TYPE = 'CM'")

    val DF5 = sql("SELECT 'ADJ' TRX_SOURCE,\n  AA.ADJUSTMENT_ID RECORD_ID,\n  0 DISTRIBUTION_ID,\n  AA.CUSTOMER_TRX_ID,\n  0 CASH_RECEIPT_ID,\n  AA.ADJUSTMENT_ID,\n  0 CREDIT_MEMO_ID,\n  T.BILL_TO_CUSTOMER_ID,\n  T.BILL_TO_SITE_USE_ID,\n  T.BILL_TO_CONTACT_ID,\n  T.SHIP_TO_CUSTOMER_ID,\n  T.SHIP_TO_SITE_USE_ID,\n  T.SHIP_TO_CONTACT_ID ,\n  T.PRIMARY_SALESREP_ID,\n  HCA5.PARTY_ID,\n  NVL(SHIP_HCA.PARTY_ID,0) SHIP_PARTY_ID,\n  AA.TYPE TRX_TYPE,\n  AA.STATUS TRX_STATUS,\n  AA.ORG_ID,\n  AA.SET_OF_BOOKS_ID LEDGER_ID,\n  AA.ADJUSTMENT_NUMBER TRX_NUMBER,\n  AA.APPLY_DATE TRX_DATE,\n  T.INVOICE_CURRENCY_CODE TRX_CURRENCY,\n  LD5.CURRENCY_CODE LEDGER_CURRENCY,\n  AA.CODE_COMBINATION_ID,\n  AA.AMOUNT TRX_CURRENCY_AMOUNT,\n  AA.ACCTD_AMOUNT LEDGER_CURRENCY_AMOUNT ,\n  0 ACCTD_AMOUNT_APPLIED_FROM,\n  0 ACCTD_AMOUNT_APPLIED_TO,\n  AA.GL_DATE,\n  AA.CREATION_DATE TRX_CREATION_DATE,\n  AA.LAST_UPDATE_DATE TRX_LAST_UPDATE_DATE\nFROM \nAR_ADJUSTMENTS_ALL AA INNER JOIN RA_CUSTOMER_TRX_ALL T ON (AA.CUSTOMER_TRX_ID = T.CUSTOMER_TRX_ID)\nINNER JOIN GL_LEDGERS LD5 ON (AA.SET_OF_BOOKS_ID = LD5.LEDGER_ID)\nINNER JOIN HZ_CUST_ACCOUNTS HCA5 ON (T.BILL_TO_CUSTOMER_ID = HCA5.CUST_ACCOUNT_ID)\nLEFT OUTER JOIN HZ_CUST_ACCOUNTS SHIP_HCA ON (T.SHIP_TO_CUSTOMER_ID = SHIP_HCA.CUST_ACCOUNT_ID)")


    val targetDF = DF1.unionAll(DF2).unionAll(DF3).unionAll(DF4).unionAll(DF5)

    // Write data into a Target table
    targetDF.write.format("orc").mode(SaveMode.Overwrite).saveAsTable(s"$TargetTable")

    // Stop the Spark Session to free up the resources
    sparksession.stop()

  }

}
